-- BEGIN BUNDLED SQL (DDL + Indexes + PKs + FKs + RLS TEMPLATES)

-- Create schemas if missing CREATE SCHEMA IF NOT EXISTS auth; CREATE SCHEMA IF NOT EXISTS storage; CREATE SCHEMA IF NOT EXISTS realtime; CREATE SCHEMA IF NOT EXISTS vault; CREATE SCHEMA IF NOT EXISTS public;

-- ==================================================================== -- TABLES -- ==================================================================== CREATE TABLE IF NOT EXISTS auth.saml_providers ( id uuid NOT NULL, sso_provider_id uuid NOT NULL, entity_id text NOT NULL, metadata_xml text NOT NULL, metadata_url text, attribute_mapping jsonb, created_at timestamp with time zone, updated_at timestamp with time zone, name_id_format text );

CREATE TABLE IF NOT EXISTS public.hub_groups ( id uuid NOT NULL DEFAULT gen_random_uuid(), name text NOT NULL, description text, icon text DEFAULT 'Communities'::text, created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP, updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP, created_by uuid );

CREATE TABLE IF NOT EXISTS realtime.subscription ( id bigint NOT NULL, subscription_id uuid NOT NULL, entity regclass NOT NULL, filters realtime.user_defined_filter[] NOT NULL DEFAULT '{}'::realtime.user_defined_filter[], claims jsonb NOT NULL, claims_role regrole NOT NULL DEFAULT realtime.to_regrole((claims ->> 'role'::text)), created_at timestamp without time zone NOT NULL DEFAULT timezone('utc'::text, now()), action_filter text DEFAULT ''::text );

CREATE TABLE IF NOT EXISTS auth.sessions ( id uuid NOT NULL, user_id uuid NOT NULL, created_at timestamp with time zone, updated_at timestamp with time zone, factor_id uuid, aal auth.aal_level, not_after timestamp with time zone, refreshed_at timestamp without time zone, user_agent text, ip inet, tag text, oauth_client_id uuid, refresh_token_hmac_key text, refresh_token_counter bigint, scopes text );

CREATE TABLE IF NOT EXISTS storage.s3_multipart_uploads ( id text NOT NULL, in_progress_size bigint NOT NULL DEFAULT 0, upload_signature text NOT NULL, bucket_id text NOT NULL, key text NOT NULL, version text NOT NULL, owner_id text, created_at timestamp with time zone NOT NULL DEFAULT now(), user_metadata jsonb );

CREATE TABLE IF NOT EXISTS auth.one_time_tokens ( id uuid NOT NULL, user_id uuid NOT NULL, token_type auth.one_time_token_type NOT NULL, token_hash text NOT NULL, relates_to text NOT NULL, created_at timestamp without time zone NOT NULL DEFAULT now(), updated_at timestamp without time zone NOT NULL DEFAULT now() );

CREATE TABLE IF NOT EXISTS auth.flow_state ( id uuid NOT NULL, user_id uuid, auth_code text, code_challenge_method auth.code_challenge_method, code_challenge text, provider_type text NOT NULL, provider_access_token text, provider_refresh_token text, created_at timestamp with time zone, updated_at timestamp with time zone, authentication_method text NOT NULL, auth_code_issued_at timestamp with time zone, invite_token text, referrer text, oauth_client_state_id uuid, linking_target_id uuid, email_optional boolean NOT NULL DEFAULT false );

CREATE TABLE IF NOT EXISTS auth.sso_providers ( id uuid NOT NULL, resource_id text, created_at timestamp with time zone, updated_at timestamp with time zone, disabled boolean );

CREATE TABLE IF NOT EXISTS public.hub_channels ( id uuid NOT NULL DEFAULT gen_random_uuid(), group_id uuid, name text NOT NULL, description text, type text DEFAULT 'text'::text, is_private boolean DEFAULT false, created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP, updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP, created_by uuid );

CREATE TABLE IF NOT EXISTS storage.buckets_vectors ( id text NOT NULL, type storage.buckettype NOT NULL DEFAULT 'VECTOR'::storage.buckettype, created_at timestamp with time zone NOT NULL DEFAULT now(), updated_at timestamp with time zone NOT NULL DEFAULT now() );

CREATE TABLE IF NOT EXISTS auth.oauth_clients ( id uuid NOT NULL, client_secret_hash text, registration_type auth.oauth_registration_type NOT NULL, redirect_uris text NOT NULL, grant_types text NOT NULL, client_name text, client_uri text, logo_uri text, created_at timestamp with time zone NOT NULL DEFAULT now(), updated_at timestamp with time zone NOT NULL DEFAULT now(), deleted_at timestamp with time zone, client_type auth.oauth_client_type NOT NULL DEFAULT 'confidential'::auth.oauth_client_type, token_endpoint_auth_method text NOT NULL );

CREATE TABLE IF NOT EXISTS auth.refresh_tokens ( instance_id uuid, id bigint NOT NULL DEFAULT nextval('auth.refresh_tokens_id_seq'::regclass), token character varying(255), user_id character varying(255), revoked boolean, created_at timestamp with time zone, updated_at timestamp with time zone, parent character varying(255), session_id uuid );

CREATE TABLE IF NOT EXISTS storage.buckets_analytics ( name text NOT NULL, type storage.buckettype NOT NULL DEFAULT 'ANALYTICS'::storage.buckettype, format text NOT NULL DEFAULT 'ICEBERG'::text, created_at timestamp with time zone NOT NULL DEFAULT now(), updated_at timestamp with time zone NOT NULL DEFAULT now(), id uuid NOT NULL DEFAULT gen_random_uuid(), deleted_at timestamp with time zone );

CREATE TABLE IF NOT EXISTS auth.oauth_authorizations ( id uuid NOT NULL, authorization_id text NOT NULL, client_id uuid NOT NULL, user_id uuid, redirect_uri text NOT NULL, scope text NOT NULL, state text, resource text, code_challenge text, code_challenge_method auth.code_challenge_method, response_type auth.oauth_response_type NOT NULL DEFAULT 'code'::auth.oauth_response_type, status auth.oauth_authorization_status NOT NULL DEFAULT 'pending'::auth.oauth_authorization_status, authorization_code text, created_at timestamp with time zone NOT NULL DEFAULT now(), expires_at timestamp with time zone NOT NULL DEFAULT (now() + '00:03:00'::interval), approved_at timestamp with time zone, nonce text );

CREATE TABLE IF NOT EXISTS auth.audit_log_entries ( instance_id uuid, id uuid NOT NULL, payload json, created_at timestamp with time zone, ip_address character varying(64) NOT NULL DEFAULT ''::character varying );

CREATE TABLE IF NOT EXISTS auth.oauth_consents ( id uuid NOT NULL, user_id uuid NOT NULL, client_id uuid NOT NULL, scopes text NOT NULL, granted_at timestamp with time zone NOT NULL DEFAULT now(), revoked_at timestamp with time zone );

CREATE TABLE IF NOT EXISTS storage.objects ( id uuid NOT NULL DEFAULT gen_random_uuid(), bucket_id text, name text, owner uuid, created_at timestamp with time zone DEFAULT now(), updated_at timestamp with time zone DEFAULT now(), last_accessed_at timestamp with time zone DEFAULT now(), metadata jsonb, path_tokens text[] DEFAULT string_to_array(name, '/'::text), version text, owner_id text, user_metadata jsonb, level integer );

CREATE TABLE IF NOT EXISTS auth.oauth_client_states ( id uuid NOT NULL, provider_type text NOT NULL, code_verifier text, created_at timestamp with time zone NOT NULL );

CREATE TABLE IF NOT EXISTS auth.identities ( provider_id text NOT NULL, user_id uuid NOT NULL, identity_data jsonb NOT NULL, provider text NOT NULL, last_sign_in_at timestamp with time zone, created_at timestamp with time zone, updated_at timestamp with time zone, email text DEFAULT lower((identity_data ->> 'email'::text)), id uuid NOT NULL DEFAULT gen_random_uuid() );

CREATE TABLE IF NOT EXISTS auth.mfa_amr_claims ( session_id uuid NOT NULL, created_at timestamp with time zone NOT NULL, updated_at timestamp with time zone NOT NULL, authentication_method text NOT NULL, id uuid NOT NULL );

CREATE TABLE IF NOT EXISTS auth.schema_migrations ( version character varying(255) NOT NULL );

CREATE TABLE IF NOT EXISTS storage.buckets ( id text NOT NULL, name text NOT NULL, owner uuid, created_at timestamp with time zone DEFAULT now(), updated_at timestamp with time zone DEFAULT now(), public boolean DEFAULT false, avif_autodetection boolean DEFAULT false, file_size_limit bigint, allowed_mime_types text[], owner_id text, type storage.buckettype NOT NULL DEFAULT 'STANDARD'::storage.buckettype );

CREATE TABLE IF NOT EXISTS auth.sso_domains ( id uuid NOT NULL, sso_provider_id uuid NOT NULL, domain text NOT NULL, created_at timestamp with time zone, updated_at timestamp with time zone );

CREATE TABLE IF NOT EXISTS auth.instances ( id uuid NOT NULL, uuid uuid, raw_base_config text, created_at timestamp with time zone, updated_at timestamp with time zone );

CREATE TABLE IF NOT EXISTS storage.prefixes ( bucket_id text NOT NULL, name text NOT NULL, level integer NOT NULL DEFAULT storage.get_level(name), created_at timestamp with time zone DEFAULT now(), updated_at timestamp with time zone DEFAULT now() );

CREATE TABLE IF NOT EXISTS auth.saml_relay_states ( id uuid NOT NULL, sso_provider_id uuid NOT NULL, request_id text NOT NULL, for_email text, redirect_to text, created_at timestamp with time zone, updated_at timestamp with time zone, flow_state_id uuid );

CREATE TABLE IF NOT EXISTS realtime.schema_migrations ( version bigint NOT NULL, inserted_at timestamp(0) without time zone );

CREATE TABLE IF NOT EXISTS auth.users ( instance_id uuid, id uuid NOT NULL, aud character varying(255), role character varying(255), email character varying(255), encrypted_password character varying(255), email_confirmed_at timestamp with time zone, invited_at timestamp with time zone, confirmation_token character varying(255), confirmation_sent_at timestamp with time zone, recovery_token character varying(255), recovery_sent_at timestamp with time zone, email_change_token_new character varying(255), email_change character varying(255), email_change_sent_at timestamp with time zone, last_sign_in_at timestamp with time zone, raw_app_meta_data jsonb, raw_user_meta_data jsonb, is_super_admin boolean, created_at timestamp with time zone, updated_at timestamp with time zone, phone text DEFAULT NULL::character varying, phone_confirmed_at timestamp with time zone, phone_change text DEFAULT ''::character varying, phone_change_token character varying(255) DEFAULT ''::character varying, phone_change_sent_at timestamp with time zone, confirmed_at timestamp with time zone DEFAULT LEAST(email_confirmed_at, phone_confirmed_at), email_change_token_current character varying(255) DEFAULT ''::character varying, email_change_confirm_status smallint DEFAULT 0, banned_until timestamp with time zone, reauthentication_token character varying(255) DEFAULT ''::character varying, reauthentication_sent_at timestamp with time zone, is_sso_user boolean NOT NULL DEFAULT false, deleted_at timestamp with time zone, is_anonymous boolean NOT NULL DEFAULT false );

CREATE TABLE IF NOT EXISTS vault.secrets ( id uuid NOT NULL DEFAULT gen_random_uuid(), name text, description text NOT NULL DEFAULT ''::text, secret text NOT NULL, key_id uuid, nonce bytea DEFAULT vault.crypto_aead_det_noncegen(), created_at timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP, updated_at timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP );

CREATE TABLE IF NOT EXISTS storage.migrations ( id integer NOT NULL, name character varying(100) NOT NULL, hash character varying(40) NOT NULL, executed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP );

CREATE TABLE IF NOT EXISTS storage.s3_multipart_uploads_parts ( id uuid NOT NULL DEFAULT gen_random_uuid(), upload_id text NOT NULL, size bigint NOT NULL DEFAULT 0, part_number integer NOT NULL, bucket_id text NOT NULL, key text NOT NULL, etag text NOT NULL, owner_id text, version text NOT NULL, created_at timestamp with time zone NOT NULL DEFAULT now() );

CREATE TABLE IF NOT EXISTS storage.vector_indexes ( id text NOT NULL DEFAULT gen_random_uuid(), name text NOT NULL, bucket_id text NOT NULL, data_type text NOT NULL, dimension integer NOT NULL, distance_metric text NOT NULL, metadata_configuration jsonb, created_at timestamp with time zone NOT NULL DEFAULT now(), updated_at timestamp with time zone NOT NULL DEFAULT now() );

CREATE TABLE IF NOT EXISTS auth.mfa_factors ( id uuid NOT NULL, user_id uuid NOT NULL, friendly_name text, factor_type auth.factor_type NOT NULL, status auth.factor_status NOT NULL, created_at timestamp with time zone NOT NULL, updated_at timestamp with time zone NOT NULL, secret text, phone text, last_challenged_at timestamp with time zone, web_authn_credential jsonb, web_authn_aaguid uuid, last_webauthn_challenge_data jsonb );

CREATE TABLE IF NOT EXISTS auth.mfa_challenges ( id uuid NOT NULL, factor_id uuid NOT NULL, created_at timestamp with time zone NOT NULL, verified_at timestamp with time zone, ip_address inet NOT NULL, otp_code text, web_authn_session_data jsonb );

-- ==================================================================== -- PRIMARY KEYS -- ==================================================================== ALTER TABLE auth.audit_log_entries ADD CONSTRAINT auth_audit_log_entries_pkey PRIMARY KEY (id); ALTER TABLE auth.flow_state ADD CONSTRAINT auth_flow_state_pkey PRIMARY KEY (id); ALTER TABLE auth.identities ADD CONSTRAINT auth_identities_pkey PRIMARY KEY (id); ALTER TABLE auth.instances ADD CONSTRAINT auth_instances_pkey PRIMARY KEY (id); ALTER TABLE auth.mfa_amr_claims ADD CONSTRAINT auth_mfa_amr_claims_pkey PRIMARY KEY (id); ALTER TABLE auth.mfa_challenges ADD CONSTRAINT auth_mfa_challenges_pkey PRIMARY KEY (id); ALTER TABLE auth.mfa_factors ADD CONSTRAINT auth_mfa_factors_pkey PRIMARY KEY (id); ALTER TABLE auth.oauth_authorizations ADD CONSTRAINT auth_oauth_authorizations_pkey PRIMARY KEY (id); ALTER TABLE auth.oauth_client_states ADD CONSTRAINT auth_oauth_client_states_pkey PRIMARY KEY (id); ALTER TABLE auth.oauth_clients ADD CONSTRAINT auth_oauth_clients_pkey PRIMARY KEY (id); ALTER TABLE auth.oauth_consents ADD CONSTRAINT auth_oauth_consents_pkey PRIMARY KEY (id); ALTER TABLE auth.one_time_tokens ADD CONSTRAINT auth_one_time_tokens_pkey PRIMARY KEY (id); ALTER TABLE auth.refresh_tokens ADD CONSTRAINT auth_refresh_tokens_pkey PRIMARY KEY (id); ALTER TABLE auth.saml_providers ADD CONSTRAINT auth_saml_providers_pkey PRIMARY KEY (id); ALTER TABLE auth.saml_relay_states ADD CONSTRAINT auth_saml_relay_states_pkey PRIMARY KEY (id); ALTER TABLE auth.schema_migrations ADD CONSTRAINT auth_schema_migrations_pkey PRIMARY KEY (version); ALTER TABLE auth.sessions ADD CONSTRAINT auth_sessions_pkey PRIMARY KEY (id); ALTER TABLE auth.sso_domains ADD CONSTRAINT auth_sso_domains_pkey PRIMARY KEY (id); ALTER TABLE auth.sso_providers ADD CONSTRAINT auth_sso_providers_pkey PRIMARY KEY (id); ALTER TABLE auth.users ADD CONSTRAINT auth_users_pkey PRIMARY KEY (id); ALTER TABLE public.hub_channels ADD CONSTRAINT public_hub_channels_pkey PRIMARY KEY (id); ALTER TABLE public.hub_groups ADD CONSTRAINT public_hub_groups_pkey PRIMARY KEY (id); -- Note: realtime.messages referenced earlier in PK list; include only if the table exists -- ALTER TABLE realtime.messages ADD CONSTRAINT realtime_messages_pkey PRIMARY KEY (id, inserted_at); ALTER TABLE realtime.schema_migrations ADD CONSTRAINT realtime_schema_migrations_pkey PRIMARY KEY (version); ALTER TABLE realtime.subscription ADD CONSTRAINT realtime_subscription_pkey PRIMARY KEY (id); ALTER TABLE storage.buckets ADD CONSTRAINT storage_buckets_pkey PRIMARY KEY (id); ALTER TABLE storage.buckets_analytics ADD CONSTRAINT storage_buckets_analytics_pkey PRIMARY KEY (id); ALTER TABLE storage.buckets_vectors ADD CONSTRAINT storage_buckets_vectors_pkey PRIMARY KEY (id); ALTER TABLE storage.migrations ADD CONSTRAINT storage_migrations_pkey PRIMARY KEY (id); ALTER TABLE storage.objects ADD CONSTRAINT storage_objects_pkey PRIMARY KEY (id); ALTER TABLE storage.prefixes ADD CONSTRAINT storage_prefixes_pkey PRIMARY KEY (bucket_id, level, name); ALTER TABLE storage.s3_multipart_uploads ADD CONSTRAINT storage_s3_multipart_uploads_pkey PRIMARY KEY (id); ALTER TABLE storage.s3_multipart_uploads_parts ADD CONSTRAINT storage_s3_multipart_uploads_parts_pkey PRIMARY KEY (id); ALTER TABLE storage.vector_indexes ADD CONSTRAINT storage_vector_indexes_pkey PRIMARY KEY (id); ALTER TABLE vault.secrets ADD CONSTRAINT vault_secrets_pkey PRIMARY KEY (id);

-- ==================================================================== -- FOREIGN KEYS -- ==================================================================== ALTER TABLE auth.identities ADD CONSTRAINT identities_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE; ALTER TABLE auth.sessions ADD CONSTRAINT sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE; ALTER TABLE auth.refresh_tokens ADD CONSTRAINT refresh_tokens_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE; ALTER TABLE auth.mfa_factors ADD CONSTRAINT mfa_factors_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE; ALTER TABLE auth.mfa_challenges ADD CONSTRAINT mfa_challenges_auth_factor_id_fkey FOREIGN KEY (factor_id) REFERENCES auth.mfa_factors(id) ON DELETE CASCADE; ALTER TABLE auth.mfa_amr_claims ADD CONSTRAINT mfa_amr_claims_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE; ALTER TABLE auth.sso_domains ADD CONSTRAINT sso_domains_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE; ALTER TABLE auth.saml_providers ADD CONSTRAINT saml_providers_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE; ALTER TABLE auth.saml_relay_states ADD CONSTRAINT saml_relay_states_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE; ALTER TABLE auth.saml_relay_states ADD CONSTRAINT saml_relay_states_flow_state_id_fkey FOREIGN KEY (flow_state_id) REFERENCES auth.flow_state(id) ON DELETE CASCADE; ALTER TABLE auth.one_time_tokens ADD CONSTRAINT one_time_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE; ALTER TABLE auth.oauth_authorizations ADD CONSTRAINT oauth_authorizations_client_id_fkey FOREIGN KEY (client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE; ALTER TABLE auth.oauth_authorizations ADD CONSTRAINT oauth_authorizations_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE; ALTER TABLE auth.oauth_consents ADD CONSTRAINT oauth_consents_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE; ALTER TABLE auth.oauth_consents ADD CONSTRAINT oauth_consents_client_id_fkey FOREIGN KEY (client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE; ALTER TABLE auth.sessions ADD CONSTRAINT sessions_oauth_client_id_fkey FOREIGN KEY (oauth_client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE; ALTER TABLE storage.objects ADD CONSTRAINT "objects_bucketId_fkey" FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id); ALTER TABLE storage.s3_multipart_uploads ADD CONSTRAINT s3_multipart_uploads_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id); ALTER TABLE storage.s3_multipart_uploads_parts ADD CONSTRAINT s3_multipart_uploads_parts_upload_id_fkey FOREIGN KEY (upload_id) REFERENCES storage.s3_multipart_uploads(id) ON DELETE CASCADE; ALTER TABLE storage.s3_multipart_uploads_parts ADD CONSTRAINT s3_multipart_uploads_parts_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id); ALTER TABLE storage.prefixes ADD CONSTRAINT "prefixes_bucketId_fkey" FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id); ALTER TABLE storage.vector_indexes ADD CONSTRAINT vector_indexes_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets_vectors(id); ALTER TABLE public.hub_groups ADD CONSTRAINT hub_groups_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE CASCADE; ALTER TABLE public.hub_channels ADD CONSTRAINT hub_channels_group_id_fkey FOREIGN KEY (group_id) REFERENCES hub_groups(id) ON DELETE CASCADE; ALTER TABLE public.hub_channels ADD CONSTRAINT hub_channels_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE CASCADE;

-- ==================================================================== -- INDEXES (non-primary) -- ==================================================================== CREATE UNIQUE INDEX saml_providers_entity_id_key ON auth.saml_providers USING btree (entity_id); CREATE INDEX saml_providers_sso_provider_id_idx ON auth.saml_providers USING btree (sso_provider_id);

CREATE INDEX idx_oauth_client_states_created_at ON auth.oauth_client_states USING btree (created_at); CREATE INDEX oauth_clients_deleted_at_idx ON auth.oauth_clients USING btree (deleted_at);

CREATE INDEX users_instance_id_idx ON auth.users USING btree (instance_id); CREATE INDEX users_instance_id_email_idx ON auth.users USING btree (instance_id, lower((email)::text)); CREATE UNIQUE INDEX confirmation_token_idx ON auth.users USING btree (confirmation_token) WHERE ((confirmation_token)::text !~ '^[0-9 ]$'::text); CREATE UNIQUE INDEX recovery_token_idx ON auth.users USING btree (recovery_token) WHERE ((recovery_token)::text !~ '^[0-9 ]$'::text); CREATE UNIQUE INDEX email_change_token_current_idx ON auth.users USING btree (email_change_token_current) WHERE ((email_change_token_current)::text !~ '^[0-9 ]$'::text); CREATE UNIQUE INDEX email_change_token_new_idx ON auth.users USING btree (email_change_token_new) WHERE ((email_change_token_new)::text !~ '^[0-9 ]$'::text); CREATE UNIQUE INDEX reauthentication_token_idx ON auth.users USING btree (reauthentication_token) WHERE ((reauthentication_token)::text !~ '^[0-9 ]$'::text); CREATE UNIQUE INDEX users_email_partial_key ON auth.users USING btree (email) WHERE (is_sso_user = false); CREATE UNIQUE INDEX users_phone_key ON auth.users USING btree (phone); CREATE INDEX users_is_anonymous_idx ON auth.users USING btree (is_anonymous);

CREATE UNIQUE INDEX secrets_name_idx ON vault.secrets USING btree (name) WHERE (name IS NOT NULL);

CREATE INDEX refresh_tokens_instance_id_idx ON auth.refresh_tokens USING btree (instance_id); CREATE INDEX refresh_tokens_instance_id_user_id_idx ON auth.refresh_tokens USING btree (instance_id, user_id); CREATE UNIQUE INDEX refresh_tokens_token_unique ON auth.refresh_tokens USING btree (token); CREATE INDEX refresh_tokens_parent_idx ON auth.refresh_tokens USING btree (parent); CREATE INDEX refresh_tokens_session_id_revoked_idx ON auth.refresh_tokens USING btree (session_id, revoked); CREATE INDEX refresh_tokens_updated_at_idx ON auth.refresh_tokens USING btree (updated_at DESC);

CREATE UNIQUE INDEX migrations_name_key ON storage.migrations USING btree (name); CREATE UNIQUE INDEX buckets_analytics_unique_name_idx ON storage.buckets_analytics USING btree (name) WHERE (deleted_at IS NULL);

CREATE UNIQUE INDEX oauth_authorizations_authorization_id_key ON auth.oauth_authorizations USING btree (authorization_id); CREATE UNIQUE INDEX oauth_authorizations_authorization_code_key ON auth.oauth_authorizations USING btree (authorization_code); CREATE INDEX oauth_auth_pending_exp_idx ON auth.oauth_authorizations USING btree (expires_at) WHERE (status = 'pending'::auth.oauth_authorization_status);

CREATE INDEX identities_user_id_idx ON auth.identities USING btree (user_id); CREATE INDEX identities_email_idx ON auth.identities USING btree (email text_pattern_ops); CREATE UNIQUE INDEX identities_provider_id_provider_unique ON auth.identities USING btree (provider_id, provider);

CREATE UNIQUE INDEX mfa_amr_claims_session_id_authentication_method_pkey ON auth.mfa_amr_claims USING btree (session_id, authentication_method);

CREATE INDEX ix_realtime_subscription_entity ON realtime.subscription USING btree (entity); CREATE UNIQUE INDEX subscription_subscription_id_entity_filters_action_filter_key ON realtime.subscription USING btree (subscription_id, entity, filters, action_filter);

CREATE INDEX audit_logs_instance_id_idx ON auth.audit_log_entries USING btree (instance_id);

CREATE UNIQUE INDEX oauth_consents_user_client_unique ON auth.oauth_consents USING btree (user_id, client_id); CREATE INDEX oauth_consents_active_user_client_idx ON auth.oauth_consents USING btree (user_id, client_id) WHERE (revoked_at IS NULL); CREATE INDEX oauth_consents_user_order_idx ON auth.oauth_consents USING btree (user_id, granted_at DESC); CREATE INDEX oauth_consents_active_client_idx ON auth.oauth_consents USING btree (client_id) WHERE (revoked_at IS NULL);

CREATE UNIQUE INDEX bname ON storage.buckets USING btree (name);

CREATE INDEX user_id_created_at_idx ON auth.sessions USING btree (user_id, created_at); CREATE INDEX sessions_user_id_idx ON auth.sessions USING btree (user_id); CREATE INDEX sessions_not_after_idx ON auth.sessions USING btree (not_after DESC); CREATE INDEX sessions_oauth_client_id_idx ON auth.sessions USING btree (oauth_client_id);

CREATE INDEX idx_multipart_uploads_list ON storage.s3_multipart_uploads USING btree (bucket_id, key, created_at);

CREATE INDEX one_time_tokens_token_hash_hash_idx ON auth.one_time_tokens USING hash (token_hash); CREATE INDEX one_time_tokens_relates_to_hash_idx ON auth.one_time_tokens USING hash (relates_to); CREATE UNIQUE INDEX one_time_tokens_user_id_token_type_key ON auth.one_time_tokens USING btree (user_id, token_type);

CREATE UNIQUE INDEX bucketid_objname ON storage.objects USING btree (bucket_id, name); CREATE INDEX name_prefix_search ON storage.objects USING btree (name text_pattern_ops); CREATE INDEX idx_objects_bucket_id_name ON storage.objects USING btree (bucket_id, name COLLATE "C"); CREATE UNIQUE INDEX idx_name_bucket_level_unique ON storage.objects USING btree (name COLLATE "C", bucket_id, level); CREATE UNIQUE INDEX objects_bucket_id_level_idx ON storage.objects USING btree (bucket_id, level, name COLLATE "C"); CREATE INDEX idx_objects_lower_name ON storage.objects USING btree ((path_tokens[level]), lower(name) text_pattern_ops, bucket_id, level);

CREATE INDEX idx_auth_code ON auth.flow_state USING btree (auth_code); CREATE INDEX idx_user_id_auth_method ON auth.flow_state USING btree (user_id, authentication_method); CREATE INDEX flow_state_created_at_idx ON auth.flow_state USING btree (created_at DESC);

CREATE INDEX messages_inserted_at_topic_index ON ONLY realtime.messages USING btree (inserted_at DESC, topic) WHERE ((extension = 'broadcast'::text) AND (private IS TRUE));

CREATE INDEX sso_domains_sso_provider_id_idx ON auth.sso_domains USING btree (sso_provider_id); CREATE UNIQUE INDEX sso_domains_domain_idx ON auth.sso_domains USING btree (lower(domain));

CREATE UNIQUE INDEX vector_indexes_name_bucket_id_idx ON storage.vector_indexes USING btree (name, bucket_id);

CREATE UNIQUE INDEX mfa_factors_user_friendly_name_unique ON auth.mfa_factors USING btree (friendly_name, user_id) WHERE (TRIM(BOTH FROM friendly_name) <> ''::text); CREATE INDEX factor_id_created_at_idx ON auth.mfa_factors USING btree (user_id, created_at); CREATE INDEX mfa_factors_user_id_idx ON auth.mfa_factors USING btree (user_id); CREATE UNIQUE INDEX unique_phone_factor_per_user ON auth.mfa_factors USING btree (user_id, phone); CREATE UNIQUE INDEX mfa_factors_last_challenged_at_key ON auth.mfa_factors USING btree (last_challenged_at);

CREATE INDEX mfa_challenge_created_at_idx ON auth.mfa_challenges USING btree (created_at DESC);

CREATE UNIQUE INDEX sso_providers_resource_id_idx ON auth.sso_providers USING btree (lower(resource_id)); CREATE INDEX sso_providers_resource_id_pattern_idx ON auth.sso_providers USING btree (resource_id text_pattern_ops);

CREATE INDEX idx_prefixes_lower_name ON storage.prefixes USING btree (bucket_id, level, ((string_to_array(name, '/'::text))[level]), lower(name) text_pattern_ops);

CREATE INDEX saml_relay_states_sso_provider_id_idx ON auth.saml_relay_states USING btree (sso_provider_id); CREATE INDEX saml_relay_states_for_email_idx ON auth.saml_relay_states USING btree (for_email); CREATE INDEX saml_relay_states_created_at_idx ON auth.saml_relay_states USING btree (created_at DESC);

-- ==================================================================== -- RLS / POLICY TEMPLATES (COMMENTED) -- ==================================================================== -- Note: RLS policies below are templates. Adjust them to your business rules, -- type casts, and helper functions (e.g., get_user_tenant()) before applying.

-- 1) auth.users — per-user ownership (recommended) -- CREATE POLICY "Users: select own" ON auth.users -- FOR SELECT TO authenticated -- USING ((SELECT auth.uid())::uuid = id); -- CREATE POLICY "Users: insert" ON auth.users -- FOR INSERT TO authenticated -- WITH CHECK ((SELECT auth.uid())::uuid = id); -- CREATE POLICY "Users: update" ON auth.users -- FOR UPDATE TO authenticated -- USING ((SELECT auth.uid())::uuid = id) -- WITH CHECK ((SELECT auth.uid())::uuid = id); -- CREATE POLICY "Users: delete" ON auth.users -- FOR DELETE TO authenticated -- USING ((SELECT auth.uid())::uuid = id);

-- 2) auth.sessions — session belongs to user -- CREATE POLICY "Sessions: user" ON auth.sessions -- FOR ALL TO authenticated -- USING (user_id = (SELECT auth.uid())::uuid) -- WITH CHECK (user_id = (SELECT auth.uid())::uuid);

-- 3) auth.refresh_tokens — scoped to session/user -- CREATE POLICY "RefreshTokens: session_owner" ON auth.refresh_tokens -- FOR SELECT TO authenticated -- USING (session_id IN (SELECT id FROM auth.sessions WHERE user_id = (SELECT auth.uid())::uuid));

-- 4) auth.identities / one_time_tokens / mfa_factors / mfa_challenges -- CREATE POLICY "Identities: user" ON auth.identities -- FOR ALL TO authenticated -- USING (user_id = (SELECT auth.uid())::uuid) -- WITH CHECK (user_id = (SELECT auth.uid())::uuid);

-- 5) storage.objects — per-user folder + public buckets -- (Assumes a bucket named 'user-uploads' where first path token is user id) -- CREATE POLICY "Storage objects: select" ON storage.objects -- FOR SELECT TO authenticated -- USING ( -- bucket_id = 'user-uploads' AND (string_to_array(name, '/'))[1] = (SELECT auth.uid())::text -- OR EXISTS (SELECT 1 FROM storage.buckets b WHERE b.id = bucket_id AND b.public = true) -- ); -- CREATE POLICY "Storage objects: insert" ON storage.objects -- FOR INSERT TO authenticated -- WITH CHECK ( -- bucket_id = 'user-uploads' AND (string_to_array(name, '/'))[1] = (SELECT auth.uid())::text -- );

-- 6) realtime.messages — room-topic membership -- (Assumes public.room_members(room_id uuid, user_id uuid)) -- CREATE POLICY "Messages: select room members" ON realtime.messages -- FOR SELECT TO authenticated -- USING ( -- topic LIKE 'room:%' AND -- EXISTS ( -- SELECT 1 FROM public.room_members rm -- WHERE rm.user_id = (SELECT auth.uid())::uuid -- AND rm.room_id = SPLIT_PART(topic, ':', 2)::uuid -- ) -- ); -- CREATE POLICY "Messages: insert room members" ON realtime.messages -- FOR INSERT TO authenticated -- WITH CHECK ( -- topic LIKE 'room:%' AND -- EXISTS ( -- SELECT 1 FROM public.room_members rm -- WHERE rm.user_id = (SELECT auth.uid())::uuid -- AND rm.room_id = SPLIT_PART(topic, ':', 2)::uuid -- ) -- );

-- 7) Helpful RLS best practices (apply as comments or code): -- - Always reference auth.uid() with a SELECT wrapper for planner stability: (SELECT auth.uid())::uuid -- - Create indexes on columns used in policies (user_id, tenant_id, bucket_id, etc.) -- - Revoke EXECUTE on SECURITY DEFINER helper functions from anon/authenticated where appropriate.

-- ==================================================================== -- NOTES & VALIDATION -- ==================================================================== -- 1) Project-specific types & functions: -- - auth.* enum types and storage.buckettype must exist in the target database. -- - vault.crypto_aead_det_noncegen() is a function provided by the vault schema — ensure it's present. -- - If any referenced types/functions are missing, create or remove references before applying. -- 2) PKs and FKs were generated from introspection. If any FK references a table you don't want, adjust manually. -- 3) I detected RLS is enabled on multiple tables in the source. However, pg_policy returned no policy rows on inspection. -- - RLS enabled but no stored policies can be a valid state; ensure you explicitly apply the RLS templates you need. -- 4) Run the script within a transaction and test with representative users: -- BEGIN; -- -- run script -- ROLLBACK; -- or COMMIT after verification*

-- END BUNDLED SQL